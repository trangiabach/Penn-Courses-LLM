{
  "version": 3,
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["packages/react/menu/src/index.ts","packages/react/menu/src/Menu.tsx","/turbopack/[project]/node_modules/.pnpm/@radix-ui+react-menu@2.0.6_@types+react-dom@18.2.18_@types+react@18.2.46_react-dom@18.2.0_react@18.2.0/node_modules/@radix-ui/react-menu/dist/index.mjs"],"sourcesContent":["export {\n  createMenuScope,\n  //\n  Menu,\n  MenuAnchor,\n  MenuPortal,\n  MenuContent,\n  MenuGroup,\n  MenuLabel,\n  MenuItem,\n  MenuCheckboxItem,\n  MenuRadioGroup,\n  MenuRadioItem,\n  MenuItemIndicator,\n  MenuSeparator,\n  MenuArrow,\n  MenuSub,\n  MenuSubTrigger,\n  MenuSubContent,\n  //\n  Root,\n  Anchor,\n  Portal,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n  Sub,\n  SubTrigger,\n  SubContent,\n} from './Menu';\nexport type {\n  MenuProps,\n  MenuAnchorProps,\n  MenuPortalProps,\n  MenuContentProps,\n  MenuGroupProps,\n  MenuLabelProps,\n  MenuItemProps,\n  MenuCheckboxItemProps,\n  MenuRadioGroupProps,\n  MenuRadioItemProps,\n  MenuItemIndicatorProps,\n  MenuSeparatorProps,\n  MenuArrowProps,\n  MenuSubProps,\n  MenuSubTriggerProps,\n  MenuSubContentProps,\n} from './Menu';\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs, composeRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { useId } from '@radix-ui/react-id';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal as PortalPrimitive } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport * as RovingFocusGroup from '@radix-ui/react-roving-focus';\nimport { createRovingFocusGroupScope } from '@radix-ui/react-roving-focus';\nimport { Slot } from '@radix-ui/react-slot';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { hideOthers } from 'aria-hidden';\nimport { RemoveScroll } from 'react-remove-scroll';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst SELECTION_KEYS = ['Enter', ' '];\nconst FIRST_KEYS = ['ArrowDown', 'PageUp', 'Home'];\nconst LAST_KEYS = ['ArrowUp', 'PageDown', 'End'];\nconst FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];\nconst SUB_OPEN_KEYS: Record<Direction, string[]> = {\n  ltr: [...SELECTION_KEYS, 'ArrowRight'],\n  rtl: [...SELECTION_KEYS, 'ArrowLeft'],\n};\nconst SUB_CLOSE_KEYS: Record<Direction, string[]> = {\n  ltr: ['ArrowLeft'],\n  rtl: ['ArrowRight'],\n};\n\n/* -------------------------------------------------------------------------------------------------\n * Menu\n * -----------------------------------------------------------------------------------------------*/\n\nconst MENU_NAME = 'Menu';\n\ntype ItemData = { disabled: boolean; textValue: string };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  MenuItemElement,\n  ItemData\n>(MENU_NAME);\n\ntype ScopedProps<P> = P & { __scopeMenu?: Scope };\nconst [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [\n  createCollectionScope,\n  createPopperScope,\n  createRovingFocusGroupScope,\n]);\nconst usePopperScope = createPopperScope();\nconst useRovingFocusGroupScope = createRovingFocusGroupScope();\n\ntype MenuContextValue = {\n  open: boolean;\n  onOpenChange(open: boolean): void;\n  content: MenuContentElement | null;\n  onContentChange(content: MenuContentElement | null): void;\n};\n\nconst [MenuProvider, useMenuContext] = createMenuContext<MenuContextValue>(MENU_NAME);\n\ntype MenuRootContextValue = {\n  onClose(): void;\n  isUsingKeyboardRef: React.RefObject<boolean>;\n  dir: Direction;\n  modal: boolean;\n};\n\nconst [MenuRootProvider, useMenuRootContext] = createMenuContext<MenuRootContextValue>(MENU_NAME);\n\ninterface MenuProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n  dir?: Direction;\n  modal?: boolean;\n}\n\nconst Menu: React.FC<MenuProps> = (props: ScopedProps<MenuProps>) => {\n  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;\n  const popperScope = usePopperScope(__scopeMenu);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const isUsingKeyboardRef = React.useRef(false);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n  const direction = useDirection(dir);\n\n  React.useEffect(() => {\n    // Capture phase ensures we set the boolean before any side effects execute\n    // in response to the key or pointer event as they might depend on this value.\n    const handleKeyDown = () => {\n      isUsingKeyboardRef.current = true;\n      document.addEventListener('pointerdown', handlePointer, { capture: true, once: true });\n      document.addEventListener('pointermove', handlePointer, { capture: true, once: true });\n    };\n    const handlePointer = () => (isUsingKeyboardRef.current = false);\n    document.addEventListener('keydown', handleKeyDown, { capture: true });\n    return () => {\n      document.removeEventListener('keydown', handleKeyDown, { capture: true });\n      document.removeEventListener('pointerdown', handlePointer, { capture: true });\n      document.removeEventListener('pointermove', handlePointer, { capture: true });\n    };\n  }, []);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n      >\n        <MenuRootProvider\n          scope={__scopeMenu}\n          onClose={React.useCallback(() => handleOpenChange(false), [handleOpenChange])}\n          isUsingKeyboardRef={isUsingKeyboardRef}\n          dir={direction}\n          modal={modal}\n        >\n          {children}\n        </MenuRootProvider>\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenu.displayName = MENU_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'MenuAnchor';\n\ntype MenuAnchorElement = React.ElementRef<typeof PopperPrimitive.Anchor>;\ntype PopperAnchorProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Anchor>;\ninterface MenuAnchorProps extends PopperAnchorProps {}\n\nconst MenuAnchor = React.forwardRef<MenuAnchorElement, MenuAnchorProps>(\n  (props: ScopedProps<MenuAnchorProps>, forwardedRef) => {\n    const { __scopeMenu, ...anchorProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Anchor {...popperScope} {...anchorProps} ref={forwardedRef} />;\n  }\n);\n\nMenuAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'MenuPortal';\n\ntype PortalContextValue = { forceMount?: true };\nconst [PortalProvider, usePortalContext] = createMenuContext<PortalContextValue>(PORTAL_NAME, {\n  forceMount: undefined,\n});\n\ntype PortalProps = React.ComponentPropsWithoutRef<typeof PortalPrimitive>;\ninterface MenuPortalProps {\n  children?: React.ReactNode;\n  /**\n   * Specify a container element to portal the content into.\n   */\n  container?: PortalProps['container'];\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuPortal: React.FC<MenuPortalProps> = (props: ScopedProps<MenuPortalProps>) => {\n  const { __scopeMenu, forceMount, children, container } = props;\n  const context = useMenuContext(PORTAL_NAME, __scopeMenu);\n  return (\n    <PortalProvider scope={__scopeMenu} forceMount={forceMount}>\n      <Presence present={forceMount || context.open}>\n        <PortalPrimitive asChild container={container}>\n          {children}\n        </PortalPrimitive>\n      </Presence>\n    </PortalProvider>\n  );\n};\n\nMenuPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'MenuContent';\n\ntype MenuContentContextValue = {\n  onItemEnter(event: React.PointerEvent): void;\n  onItemLeave(event: React.PointerEvent): void;\n  onTriggerLeave(event: React.PointerEvent): void;\n  searchRef: React.RefObject<string>;\n  pointerGraceTimerRef: React.MutableRefObject<number>;\n  onPointerGraceIntentChange(intent: GraceIntent | null): void;\n};\nconst [MenuContentProvider, useMenuContentContext] =\n  createMenuContext<MenuContentContextValue>(CONTENT_NAME);\n\ntype MenuContentElement = MenuRootContentTypeElement;\n/**\n * We purposefully don't union MenuRootContent and MenuSubContent props here because\n * they have conflicting prop types. We agreed that we would allow MenuSubContent to\n * accept props that it would just ignore.\n */\ninterface MenuContentProps extends MenuRootContentTypeProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuContent = React.forwardRef<MenuContentElement, MenuContentProps>(\n  (props: ScopedProps<MenuContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n    const { forceMount = portalContext.forceMount, ...contentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            {rootContext.modal ? (\n              <MenuRootContentModal {...contentProps} ref={forwardedRef} />\n            ) : (\n              <MenuRootContentNonModal {...contentProps} ref={forwardedRef} />\n            )}\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuRootContentTypeElement = MenuContentImplElement;\ninterface MenuRootContentTypeProps\n  extends Omit<MenuContentImplProps, keyof MenuContentImplPrivateProps> {}\n\nconst MenuRootContentModal = React.forwardRef<MenuRootContentTypeElement, MenuRootContentTypeProps>(\n  (props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuRootContentTypeElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    // Hide everything from ARIA except the `MenuContent`\n    React.useEffect(() => {\n      const content = ref.current;\n      if (content) return hideOthers(content);\n    }, []);\n\n    return (\n      <MenuContentImpl\n        {...props}\n        ref={composedRefs}\n        // we make sure we're not trapping once it's been closed\n        // (closed !== unmounted when animating out)\n        trapFocus={context.open}\n        // make sure to only disable pointer events when open\n        // this avoids blocking interactions while animating out\n        disableOutsidePointerEvents={context.open}\n        disableOutsideScroll\n        // When focus is trapped, a `focusout` event may still happen.\n        // We make sure we don't trigger our `onDismiss` in such case.\n        onFocusOutside={composeEventHandlers(\n          props.onFocusOutside,\n          (event) => event.preventDefault(),\n          { checkForDefaultPrevented: false }\n        )}\n        onDismiss={() => context.onOpenChange(false)}\n      />\n    );\n  }\n);\n\nconst MenuRootContentNonModal = React.forwardRef<\n  MenuRootContentTypeElement,\n  MenuRootContentTypeProps\n>((props: ScopedProps<MenuRootContentTypeProps>, forwardedRef) => {\n  const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n  return (\n    <MenuContentImpl\n      {...props}\n      ref={forwardedRef}\n      trapFocus={false}\n      disableOutsidePointerEvents={false}\n      disableOutsideScroll={false}\n      onDismiss={() => context.onOpenChange(false)}\n    />\n  );\n});\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuContentImplElement = React.ElementRef<typeof PopperPrimitive.Content>;\ntype FocusScopeProps = Radix.ComponentPropsWithoutRef<typeof FocusScope>;\ntype DismissableLayerProps = Radix.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype RovingFocusGroupProps = Radix.ComponentPropsWithoutRef<typeof RovingFocusGroup.Root>;\ntype PopperContentProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ntype MenuContentImplPrivateProps = {\n  onOpenAutoFocus?: FocusScopeProps['onMountAutoFocus'];\n  onDismiss?: DismissableLayerProps['onDismiss'];\n  disableOutsidePointerEvents?: DismissableLayerProps['disableOutsidePointerEvents'];\n\n  /**\n   * Whether scrolling outside the `MenuContent` should be prevented\n   * (default: `false`)\n   */\n  disableOutsideScroll?: boolean;\n\n  /**\n   * Whether focus should be trapped within the `MenuContent`\n   * (default: false)\n   */\n  trapFocus?: FocusScopeProps['trapped'];\n};\ninterface MenuContentImplProps\n  extends MenuContentImplPrivateProps,\n    Omit<PopperContentProps, 'dir' | 'onPlaced'> {\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: RovingFocusGroupProps['loop'];\n\n  onEntryFocus?: RovingFocusGroupProps['onEntryFocus'];\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPointerDownOutside?: DismissableLayerProps['onPointerDownOutside'];\n  onFocusOutside?: DismissableLayerProps['onFocusOutside'];\n  onInteractOutside?: DismissableLayerProps['onInteractOutside'];\n}\n\nconst MenuContentImpl = React.forwardRef<MenuContentImplElement, MenuContentImplProps>(\n  (props: ScopedProps<MenuContentImplProps>, forwardedRef) => {\n    const {\n      __scopeMenu,\n      loop = false,\n      trapFocus,\n      onOpenAutoFocus,\n      onCloseAutoFocus,\n      disableOutsidePointerEvents,\n      onEntryFocus,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      disableOutsideScroll,\n      ...contentProps\n    } = props;\n    const context = useMenuContext(CONTENT_NAME, __scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, __scopeMenu);\n    const popperScope = usePopperScope(__scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const getItems = useCollection(__scopeMenu);\n    const [currentItemId, setCurrentItemId] = React.useState<string | null>(null);\n    const contentRef = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);\n    const timerRef = React.useRef(0);\n    const searchRef = React.useRef('');\n    const pointerGraceTimerRef = React.useRef(0);\n    const pointerGraceIntentRef = React.useRef<GraceIntent | null>(null);\n    const pointerDirRef = React.useRef<Side>('right');\n    const lastPointerXRef = React.useRef(0);\n\n    const ScrollLockWrapper = disableOutsideScroll ? RemoveScroll : React.Fragment;\n    const scrollLockWrapperProps = disableOutsideScroll\n      ? { as: Slot, allowPinchZoom: true }\n      : undefined;\n\n    const handleTypeaheadSearch = (key: string) => {\n      const search = searchRef.current + key;\n      const items = getItems().filter((item) => !item.disabled);\n      const currentItem = document.activeElement;\n      const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;\n      const values = items.map((item) => item.textValue);\n      const nextMatch = getNextMatch(values, search, currentMatch);\n      const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;\n\n      // Reset `searchRef` 1 second after it was last updated\n      (function updateSearch(value: string) {\n        searchRef.current = value;\n        window.clearTimeout(timerRef.current);\n        if (value !== '') timerRef.current = window.setTimeout(() => updateSearch(''), 1000);\n      })(search);\n\n      if (newItem) {\n        /**\n         * Imperative focus during keydown is risky so we prevent React's batching updates\n         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n         */\n        setTimeout(() => (newItem as HTMLElement).focus());\n      }\n    };\n\n    React.useEffect(() => {\n      return () => window.clearTimeout(timerRef.current);\n    }, []);\n\n    // Make sure the whole tree has focus guards as our `MenuContent` may be\n    // the last element in the DOM (beacuse of the `Portal`)\n    useFocusGuards();\n\n    const isPointerMovingToSubmenu = React.useCallback((event: React.PointerEvent) => {\n      const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;\n      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);\n    }, []);\n\n    return (\n      <MenuContentProvider\n        scope={__scopeMenu}\n        searchRef={searchRef}\n        onItemEnter={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) event.preventDefault();\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        onItemLeave={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) return;\n            contentRef.current?.focus();\n            setCurrentItemId(null);\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        onTriggerLeave={React.useCallback(\n          (event) => {\n            if (isPointerMovingToSubmenu(event)) event.preventDefault();\n          },\n          [isPointerMovingToSubmenu]\n        )}\n        pointerGraceTimerRef={pointerGraceTimerRef}\n        onPointerGraceIntentChange={React.useCallback((intent) => {\n          pointerGraceIntentRef.current = intent;\n        }, [])}\n      >\n        <ScrollLockWrapper {...scrollLockWrapperProps}>\n          <FocusScope\n            asChild\n            trapped={trapFocus}\n            onMountAutoFocus={composeEventHandlers(onOpenAutoFocus, (event) => {\n              // when opening, explicitly focus the content area only and leave\n              // `onEntryFocus` in  control of focusing first item\n              event.preventDefault();\n              contentRef.current?.focus();\n            })}\n            onUnmountAutoFocus={onCloseAutoFocus}\n          >\n            <DismissableLayer\n              asChild\n              disableOutsidePointerEvents={disableOutsidePointerEvents}\n              onEscapeKeyDown={onEscapeKeyDown}\n              onPointerDownOutside={onPointerDownOutside}\n              onFocusOutside={onFocusOutside}\n              onInteractOutside={onInteractOutside}\n              onDismiss={onDismiss}\n            >\n              <RovingFocusGroup.Root\n                asChild\n                {...rovingFocusGroupScope}\n                dir={rootContext.dir}\n                orientation=\"vertical\"\n                loop={loop}\n                currentTabStopId={currentItemId}\n                onCurrentTabStopIdChange={setCurrentItemId}\n                onEntryFocus={composeEventHandlers(onEntryFocus, (event) => {\n                  // only focus first item when using keyboard\n                  if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();\n                })}\n              >\n                <PopperPrimitive.Content\n                  role=\"menu\"\n                  aria-orientation=\"vertical\"\n                  data-state={getOpenState(context.open)}\n                  data-radix-menu-content=\"\"\n                  dir={rootContext.dir}\n                  {...popperScope}\n                  {...contentProps}\n                  ref={composedRefs}\n                  style={{ outline: 'none', ...contentProps.style }}\n                  onKeyDown={composeEventHandlers(contentProps.onKeyDown, (event) => {\n                    // submenu key events bubble through portals. We only care about keys in this menu.\n                    const target = event.target as HTMLElement;\n                    const isKeyDownInside =\n                      target.closest('[data-radix-menu-content]') === event.currentTarget;\n                    const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n                    const isCharacterKey = event.key.length === 1;\n                    if (isKeyDownInside) {\n                      // menus should not be navigated using tab key so we prevent it\n                      if (event.key === 'Tab') event.preventDefault();\n                      if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);\n                    }\n                    // focus first/last item based on key pressed\n                    const content = contentRef.current;\n                    if (event.target !== content) return;\n                    if (!FIRST_LAST_KEYS.includes(event.key)) return;\n                    event.preventDefault();\n                    const items = getItems().filter((item) => !item.disabled);\n                    const candidateNodes = items.map((item) => item.ref.current!);\n                    if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();\n                    focusFirst(candidateNodes);\n                  })}\n                  onBlur={composeEventHandlers(props.onBlur, (event) => {\n                    // clear search buffer when leaving the menu\n                    if (!event.currentTarget.contains(event.target)) {\n                      window.clearTimeout(timerRef.current);\n                      searchRef.current = '';\n                    }\n                  })}\n                  onPointerMove={composeEventHandlers(\n                    props.onPointerMove,\n                    whenMouse((event) => {\n                      const target = event.target as HTMLElement;\n                      const pointerXHasChanged = lastPointerXRef.current !== event.clientX;\n\n                      // We don't use `event.movementX` for this check because Safari will\n                      // always return `0` on a pointer event.\n                      if (event.currentTarget.contains(target) && pointerXHasChanged) {\n                        const newDir = event.clientX > lastPointerXRef.current ? 'right' : 'left';\n                        pointerDirRef.current = newDir;\n                        lastPointerXRef.current = event.clientX;\n                      }\n                    })\n                  )}\n                />\n              </RovingFocusGroup.Root>\n            </DismissableLayer>\n          </FocusScope>\n        </ScrollLockWrapper>\n      </MenuContentProvider>\n    );\n  }\n);\n\nMenuContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'MenuGroup';\n\ntype MenuGroupElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface MenuGroupProps extends PrimitiveDivProps {}\n\nconst MenuGroup = React.forwardRef<MenuGroupElement, MenuGroupProps>(\n  (props: ScopedProps<MenuGroupProps>, forwardedRef) => {\n    const { __scopeMenu, ...groupProps } = props;\n    return <Primitive.div role=\"group\" {...groupProps} ref={forwardedRef} />;\n  }\n);\n\nMenuGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'MenuLabel';\n\ntype MenuLabelElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuLabelProps extends PrimitiveDivProps {}\n\nconst MenuLabel = React.forwardRef<MenuLabelElement, MenuLabelProps>(\n  (props: ScopedProps<MenuLabelProps>, forwardedRef) => {\n    const { __scopeMenu, ...labelProps } = props;\n    return <Primitive.div {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nMenuLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'MenuItem';\nconst ITEM_SELECT = 'menu.itemSelect';\n\ntype MenuItemElement = MenuItemImplElement;\ninterface MenuItemProps extends Omit<MenuItemImplProps, 'onSelect'> {\n  onSelect?: (event: Event) => void;\n}\n\nconst MenuItem = React.forwardRef<MenuItemElement, MenuItemProps>(\n  (props: ScopedProps<MenuItemProps>, forwardedRef) => {\n    const { disabled = false, onSelect, ...itemProps } = props;\n    const ref = React.useRef<HTMLDivElement>(null);\n    const rootContext = useMenuRootContext(ITEM_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(ITEM_NAME, props.__scopeMenu);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const isPointerDownRef = React.useRef(false);\n\n    const handleSelect = () => {\n      const menuItem = ref.current;\n      if (!disabled && menuItem) {\n        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });\n        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });\n        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);\n        if (itemSelectEvent.defaultPrevented) {\n          isPointerDownRef.current = false;\n        } else {\n          rootContext.onClose();\n        }\n      }\n    };\n\n    return (\n      <MenuItemImpl\n        {...itemProps}\n        ref={composedRefs}\n        disabled={disabled}\n        onClick={composeEventHandlers(props.onClick, handleSelect)}\n        onPointerDown={(event) => {\n          props.onPointerDown?.(event);\n          isPointerDownRef.current = true;\n        }}\n        onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n          // Pointer down can move to a different menu item which should activate it on pointer up.\n          // We dispatch a click for selection to allow composition with click based triggers and to\n          // prevent Firefox from getting stuck in text selection mode when the menu closes.\n          if (!isPointerDownRef.current) event.currentTarget?.click();\n        })}\n        onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n          const isTypingAhead = contentContext.searchRef.current !== '';\n          if (disabled || (isTypingAhead && event.key === ' ')) return;\n          if (SELECTION_KEYS.includes(event.key)) {\n            event.currentTarget.click();\n            /**\n             * We prevent default browser behaviour for selection keys as they should trigger\n             * a selection only:\n             * - prevents space from scrolling the page.\n             * - if keydown causes focus to move, prevents keydown from firing on the new target.\n             */\n            event.preventDefault();\n          }\n        })}\n      />\n    );\n  }\n);\n\nMenuItem.displayName = ITEM_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype MenuItemImplElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuItemImplProps extends PrimitiveDivProps {\n  disabled?: boolean;\n  textValue?: string;\n}\n\nconst MenuItemImpl = React.forwardRef<MenuItemImplElement, MenuItemImplProps>(\n  (props: ScopedProps<MenuItemImplProps>, forwardedRef) => {\n    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;\n    const contentContext = useMenuContentContext(ITEM_NAME, __scopeMenu);\n    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeMenu);\n    const ref = React.useRef<HTMLDivElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const [isFocused, setIsFocused] = React.useState(false);\n\n    // get the item's `.textContent` as default strategy for typeahead `textValue`\n    const [textContent, setTextContent] = React.useState('');\n    React.useEffect(() => {\n      const menuItem = ref.current;\n      if (menuItem) {\n        setTextContent((menuItem.textContent ?? '').trim());\n      }\n    }, [itemProps.children]);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeMenu}\n        disabled={disabled}\n        textValue={textValue ?? textContent}\n      >\n        <RovingFocusGroup.Item asChild {...rovingFocusGroupScope} focusable={!disabled}>\n          <Primitive.div\n            role=\"menuitem\"\n            data-highlighted={isFocused ? '' : undefined}\n            aria-disabled={disabled || undefined}\n            data-disabled={disabled ? '' : undefined}\n            {...itemProps}\n            ref={composedRefs}\n            /**\n             * We focus items on `pointerMove` to achieve the following:\n             *\n             * - Mouse over an item (it focuses)\n             * - Leave mouse where it is and use keyboard to focus a different item\n             * - Wiggle mouse without it leaving previously focused item\n             * - Previously focused item should re-focus\n             *\n             * If we used `mouseOver`/`mouseEnter` it would not re-focus when the mouse\n             * wiggles. This is to match native menu implementation.\n             */\n            onPointerMove={composeEventHandlers(\n              props.onPointerMove,\n              whenMouse((event) => {\n                if (disabled) {\n                  contentContext.onItemLeave(event);\n                } else {\n                  contentContext.onItemEnter(event);\n                  if (!event.defaultPrevented) {\n                    const item = event.currentTarget;\n                    item.focus();\n                  }\n                }\n              })\n            )}\n            onPointerLeave={composeEventHandlers(\n              props.onPointerLeave,\n              whenMouse((event) => contentContext.onItemLeave(event))\n            )}\n            onFocus={composeEventHandlers(props.onFocus, () => setIsFocused(true))}\n            onBlur={composeEventHandlers(props.onBlur, () => setIsFocused(false))}\n          />\n        </RovingFocusGroup.Item>\n      </Collection.ItemSlot>\n    );\n  }\n);\n\n/* -------------------------------------------------------------------------------------------------\n * MenuCheckboxItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst CHECKBOX_ITEM_NAME = 'MenuCheckboxItem';\n\ntype MenuCheckboxItemElement = MenuItemElement;\n\ntype CheckedState = boolean | 'indeterminate';\n\ninterface MenuCheckboxItemProps extends MenuItemProps {\n  checked?: CheckedState;\n  // `onCheckedChange` can never be called with `\"indeterminate\"` from the inside\n  onCheckedChange?: (checked: boolean) => void;\n}\n\nconst MenuCheckboxItem = React.forwardRef<MenuCheckboxItemElement, MenuCheckboxItemProps>(\n  (props: ScopedProps<MenuCheckboxItemProps>, forwardedRef) => {\n    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemcheckbox\"\n          aria-checked={isIndeterminate(checked) ? 'mixed' : checked}\n          {...checkboxItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            checkboxItemProps.onSelect,\n            () => onCheckedChange?.(isIndeterminate(checked) ? true : !checked),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_GROUP_NAME = 'MenuRadioGroup';\n\nconst [RadioGroupProvider, useRadioGroupContext] = createMenuContext<MenuRadioGroupProps>(\n  RADIO_GROUP_NAME,\n  { value: undefined, onValueChange: () => {} }\n);\n\ntype MenuRadioGroupElement = React.ElementRef<typeof MenuGroup>;\ninterface MenuRadioGroupProps extends MenuGroupProps {\n  value?: string;\n  onValueChange?: (value: string) => void;\n}\n\nconst MenuRadioGroup = React.forwardRef<MenuRadioGroupElement, MenuRadioGroupProps>(\n  (props: ScopedProps<MenuRadioGroupProps>, forwardedRef) => {\n    const { value, onValueChange, ...groupProps } = props;\n    const handleValueChange = useCallbackRef(onValueChange);\n    return (\n      <RadioGroupProvider scope={props.__scopeMenu} value={value} onValueChange={handleValueChange}>\n        <MenuGroup {...groupProps} ref={forwardedRef} />\n      </RadioGroupProvider>\n    );\n  }\n);\n\nMenuRadioGroup.displayName = RADIO_GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuRadioItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst RADIO_ITEM_NAME = 'MenuRadioItem';\n\ntype MenuRadioItemElement = React.ElementRef<typeof MenuItem>;\ninterface MenuRadioItemProps extends MenuItemProps {\n  value: string;\n}\n\nconst MenuRadioItem = React.forwardRef<MenuRadioItemElement, MenuRadioItemProps>(\n  (props: ScopedProps<MenuRadioItemProps>, forwardedRef) => {\n    const { value, ...radioItemProps } = props;\n    const context = useRadioGroupContext(RADIO_ITEM_NAME, props.__scopeMenu);\n    const checked = value === context.value;\n    return (\n      <ItemIndicatorProvider scope={props.__scopeMenu} checked={checked}>\n        <MenuItem\n          role=\"menuitemradio\"\n          aria-checked={checked}\n          {...radioItemProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(checked)}\n          onSelect={composeEventHandlers(\n            radioItemProps.onSelect,\n            () => context.onValueChange?.(value),\n            { checkForDefaultPrevented: false }\n          )}\n        />\n      </ItemIndicatorProvider>\n    );\n  }\n);\n\nMenuRadioItem.displayName = RADIO_ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_INDICATOR_NAME = 'MenuItemIndicator';\n\ntype CheckboxContextValue = { checked: CheckedState };\n\nconst [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext<CheckboxContextValue>(\n  ITEM_INDICATOR_NAME,\n  { checked: false }\n);\n\ntype MenuItemIndicatorElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface MenuItemIndicatorProps extends PrimitiveSpanProps {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuItemIndicator = React.forwardRef<MenuItemIndicatorElement, MenuItemIndicatorProps>(\n  (props: ScopedProps<MenuItemIndicatorProps>, forwardedRef) => {\n    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;\n    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME, __scopeMenu);\n    return (\n      <Presence\n        present={\n          forceMount ||\n          isIndeterminate(indicatorContext.checked) ||\n          indicatorContext.checked === true\n        }\n      >\n        <Primitive.span\n          {...itemIndicatorProps}\n          ref={forwardedRef}\n          data-state={getCheckedState(indicatorContext.checked)}\n        />\n      </Presence>\n    );\n  }\n);\n\nMenuItemIndicator.displayName = ITEM_INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'MenuSeparator';\n\ntype MenuSeparatorElement = React.ElementRef<typeof Primitive.div>;\ninterface MenuSeparatorProps extends PrimitiveDivProps {}\n\nconst MenuSeparator = React.forwardRef<MenuSeparatorElement, MenuSeparatorProps>(\n  (props: ScopedProps<MenuSeparatorProps>, forwardedRef) => {\n    const { __scopeMenu, ...separatorProps } = props;\n    return (\n      <Primitive.div\n        role=\"separator\"\n        aria-orientation=\"horizontal\"\n        {...separatorProps}\n        ref={forwardedRef}\n      />\n    );\n  }\n);\n\nMenuSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'MenuArrow';\n\ntype MenuArrowElement = React.ElementRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = Radix.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface MenuArrowProps extends PopperArrowProps {}\n\nconst MenuArrow = React.forwardRef<MenuArrowElement, MenuArrowProps>(\n  (props: ScopedProps<MenuArrowProps>, forwardedRef) => {\n    const { __scopeMenu, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeMenu);\n    return <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />;\n  }\n);\n\nMenuArrow.displayName = ARROW_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSub\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_NAME = 'MenuSub';\n\ntype MenuSubContextValue = {\n  contentId: string;\n  triggerId: string;\n  trigger: MenuSubTriggerElement | null;\n  onTriggerChange(trigger: MenuSubTriggerElement | null): void;\n};\n\nconst [MenuSubProvider, useMenuSubContext] = createMenuContext<MenuSubContextValue>(SUB_NAME);\n\ninterface MenuSubProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  onOpenChange?(open: boolean): void;\n}\n\nconst MenuSub: React.FC<MenuSubProps> = (props: ScopedProps<MenuSubProps>) => {\n  const { __scopeMenu, children, open = false, onOpenChange } = props;\n  const parentMenuContext = useMenuContext(SUB_NAME, __scopeMenu);\n  const popperScope = usePopperScope(__scopeMenu);\n  const [trigger, setTrigger] = React.useState<MenuSubTriggerElement | null>(null);\n  const [content, setContent] = React.useState<MenuContentElement | null>(null);\n  const handleOpenChange = useCallbackRef(onOpenChange);\n\n  // Prevent the parent menu from reopening with open submenus.\n  React.useEffect(() => {\n    if (parentMenuContext.open === false) handleOpenChange(false);\n    return () => handleOpenChange(false);\n  }, [parentMenuContext.open, handleOpenChange]);\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <MenuProvider\n        scope={__scopeMenu}\n        open={open}\n        onOpenChange={handleOpenChange}\n        content={content}\n        onContentChange={setContent}\n      >\n        <MenuSubProvider\n          scope={__scopeMenu}\n          contentId={useId()}\n          triggerId={useId()}\n          trigger={trigger}\n          onTriggerChange={setTrigger}\n        >\n          {children}\n        </MenuSubProvider>\n      </MenuProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nMenuSub.displayName = SUB_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_TRIGGER_NAME = 'MenuSubTrigger';\n\ntype MenuSubTriggerElement = MenuItemImplElement;\ninterface MenuSubTriggerProps extends MenuItemImplProps {}\n\nconst MenuSubTrigger = React.forwardRef<MenuSubTriggerElement, MenuSubTriggerProps>(\n  (props: ScopedProps<MenuSubTriggerProps>, forwardedRef) => {\n    const context = useMenuContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const subContext = useMenuSubContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME, props.__scopeMenu);\n    const openTimerRef = React.useRef<number | null>(null);\n    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;\n    const scope = { __scopeMenu: props.__scopeMenu };\n\n    const clearOpenTimer = React.useCallback(() => {\n      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);\n      openTimerRef.current = null;\n    }, []);\n\n    React.useEffect(() => clearOpenTimer, [clearOpenTimer]);\n\n    React.useEffect(() => {\n      const pointerGraceTimer = pointerGraceTimerRef.current;\n      return () => {\n        window.clearTimeout(pointerGraceTimer);\n        onPointerGraceIntentChange(null);\n      };\n    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);\n\n    return (\n      <MenuAnchor asChild {...scope}>\n        <MenuItemImpl\n          id={subContext.triggerId}\n          aria-haspopup=\"menu\"\n          aria-expanded={context.open}\n          aria-controls={subContext.contentId}\n          data-state={getOpenState(context.open)}\n          {...props}\n          ref={composeRefs(forwardedRef, subContext.onTriggerChange)}\n          // This is redundant for mouse users but we cannot determine pointer type from\n          // click event and we cannot use pointerup event (see git history for reasons why)\n          onClick={(event) => {\n            props.onClick?.(event);\n            if (props.disabled || event.defaultPrevented) return;\n            /**\n             * We manually focus because iOS Safari doesn't always focus on click (e.g. buttons)\n             * and we rely heavily on `onFocusOutside` for submenus to close when switching\n             * between separate submenus.\n             */\n            event.currentTarget.focus();\n            if (!context.open) context.onOpenChange(true);\n          }}\n          onPointerMove={composeEventHandlers(\n            props.onPointerMove,\n            whenMouse((event) => {\n              contentContext.onItemEnter(event);\n              if (event.defaultPrevented) return;\n              if (!props.disabled && !context.open && !openTimerRef.current) {\n                contentContext.onPointerGraceIntentChange(null);\n                openTimerRef.current = window.setTimeout(() => {\n                  context.onOpenChange(true);\n                  clearOpenTimer();\n                }, 100);\n              }\n            })\n          )}\n          onPointerLeave={composeEventHandlers(\n            props.onPointerLeave,\n            whenMouse((event) => {\n              clearOpenTimer();\n\n              const contentRect = context.content?.getBoundingClientRect();\n              if (contentRect) {\n                // TODO: make sure to update this when we change positioning logic\n                const side = context.content?.dataset.side as Side;\n                const rightSide = side === 'right';\n                const bleed = rightSide ? -5 : +5;\n                const contentNearEdge = contentRect[rightSide ? 'left' : 'right'];\n                const contentFarEdge = contentRect[rightSide ? 'right' : 'left'];\n\n                contentContext.onPointerGraceIntentChange({\n                  area: [\n                    // Apply a bleed on clientX to ensure that our exit point is\n                    // consistently within polygon bounds\n                    { x: event.clientX + bleed, y: event.clientY },\n                    { x: contentNearEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.top },\n                    { x: contentFarEdge, y: contentRect.bottom },\n                    { x: contentNearEdge, y: contentRect.bottom },\n                  ],\n                  side,\n                });\n\n                window.clearTimeout(pointerGraceTimerRef.current);\n                pointerGraceTimerRef.current = window.setTimeout(\n                  () => contentContext.onPointerGraceIntentChange(null),\n                  300\n                );\n              } else {\n                contentContext.onTriggerLeave(event);\n                if (event.defaultPrevented) return;\n\n                // There's 100ms where the user may leave an item before the submenu was opened.\n                contentContext.onPointerGraceIntentChange(null);\n              }\n            })\n          )}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            const isTypingAhead = contentContext.searchRef.current !== '';\n            if (props.disabled || (isTypingAhead && event.key === ' ')) return;\n            if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {\n              context.onOpenChange(true);\n              // The trigger may hold focus if opened via pointer interaction\n              // so we ensure content is given focus again when switching to keyboard.\n              context.content?.focus();\n              // prevent window from scrolling\n              event.preventDefault();\n            }\n          })}\n        />\n      </MenuAnchor>\n    );\n  }\n);\n\nMenuSubTrigger.displayName = SUB_TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * MenuSubContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst SUB_CONTENT_NAME = 'MenuSubContent';\n\ntype MenuSubContentElement = MenuContentImplElement;\ninterface MenuSubContentProps\n  extends Omit<\n    MenuContentImplProps,\n    keyof MenuContentImplPrivateProps | 'onCloseAutoFocus' | 'onEntryFocus' | 'side' | 'align'\n  > {\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst MenuSubContent = React.forwardRef<MenuSubContentElement, MenuSubContentProps>(\n  (props: ScopedProps<MenuSubContentProps>, forwardedRef) => {\n    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeMenu);\n    const { forceMount = portalContext.forceMount, ...subContentProps } = props;\n    const context = useMenuContext(CONTENT_NAME, props.__scopeMenu);\n    const rootContext = useMenuRootContext(CONTENT_NAME, props.__scopeMenu);\n    const subContext = useMenuSubContext(SUB_CONTENT_NAME, props.__scopeMenu);\n    const ref = React.useRef<MenuSubContentElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    return (\n      <Collection.Provider scope={props.__scopeMenu}>\n        <Presence present={forceMount || context.open}>\n          <Collection.Slot scope={props.__scopeMenu}>\n            <MenuContentImpl\n              id={subContext.contentId}\n              aria-labelledby={subContext.triggerId}\n              {...subContentProps}\n              ref={composedRefs}\n              align=\"start\"\n              side={rootContext.dir === 'rtl' ? 'left' : 'right'}\n              disableOutsidePointerEvents={false}\n              disableOutsideScroll={false}\n              trapFocus={false}\n              onOpenAutoFocus={(event) => {\n                // when opening a submenu, focus content for keyboard users only\n                if (rootContext.isUsingKeyboardRef.current) ref.current?.focus();\n                event.preventDefault();\n              }}\n              // The menu might close because of focusing another menu item in the parent menu. We\n              // don't want it to refocus the trigger in that case so we handle trigger focus ourselves.\n              onCloseAutoFocus={(event) => event.preventDefault()}\n              onFocusOutside={composeEventHandlers(props.onFocusOutside, (event) => {\n                // We prevent closing when the trigger is focused to avoid triggering a re-open animation\n                // on pointer interaction.\n                if (event.target !== subContext.trigger) context.onOpenChange(false);\n              })}\n              onEscapeKeyDown={composeEventHandlers(props.onEscapeKeyDown, (event) => {\n                rootContext.onClose();\n                // ensure pressing escape in submenu doesn't escape full screen mode\n                event.preventDefault();\n              })}\n              onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                // Submenu key events bubble through portals. We only care about keys in this menu.\n                const isKeyDownInside = event.currentTarget.contains(event.target as HTMLElement);\n                const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);\n                if (isKeyDownInside && isCloseKey) {\n                  context.onOpenChange(false);\n                  // We focus manually because we prevented it in `onCloseAutoFocus`\n                  subContext.trigger?.focus();\n                  // prevent window from scrolling\n                  event.preventDefault();\n                }\n              })}\n            />\n          </Collection.Slot>\n        </Presence>\n      </Collection.Provider>\n    );\n  }\n);\n\nMenuSubContent.displayName = SUB_CONTENT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getOpenState(open: boolean) {\n  return open ? 'open' : 'closed';\n}\n\nfunction isIndeterminate(checked?: CheckedState): checked is 'indeterminate' {\n  return checked === 'indeterminate';\n}\n\nfunction getCheckedState(checked: CheckedState) {\n  return isIndeterminate(checked) ? 'indeterminate' : checked ? 'checked' : 'unchecked';\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\n/**\n * This is the \"meat\" of the typeahead matching logic. It takes in all the values,\n * the search and the current match, and returns the next match (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through options starting with that character)\n *\n * We also reorder the values by wrapping the array around the current match.\n * This is so we always look forward from the current match, and picking the first\n * match will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current match from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current match still matches.\n */\nfunction getNextMatch(values: string[], search: string, currentMatch?: string) {\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0] : search;\n  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;\n  let wrappedValues = wrapArray(values, Math.max(currentMatchIndex, 0));\n  const excludeCurrentMatch = normalizedSearch.length === 1;\n  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v) => v !== currentMatch);\n  const nextMatch = wrappedValues.find((value) =>\n    value.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextMatch !== currentMatch ? nextMatch : undefined;\n}\n\ntype Point = { x: number; y: number };\ntype Polygon = Point[];\ntype Side = 'left' | 'right';\ntype GraceIntent = { area: Polygon; side: Side };\n\n// Determine if a point is inside of a polygon.\n// Based on https://github.com/substack/point-in-polygon\nfunction isPointInPolygon(point: Point, polygon: Polygon) {\n  const { x, y } = point;\n  let inside = false;\n  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n    const xi = polygon[i].x;\n    const yi = polygon[i].y;\n    const xj = polygon[j].x;\n    const yj = polygon[j].y;\n\n    // prettier-ignore\n    const intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n    if (intersect) inside = !inside;\n  }\n\n  return inside;\n}\n\nfunction isPointerInGraceArea(event: React.PointerEvent, area?: Polygon) {\n  if (!area) return false;\n  const cursorPos = { x: event.clientX, y: event.clientY };\n  return isPointInPolygon(cursorPos, area);\n}\n\nfunction whenMouse<E>(handler: React.PointerEventHandler<E>): React.PointerEventHandler<E> {\n  return (event) => (event.pointerType === 'mouse' ? handler(event) : undefined);\n}\n\nconst Root = Menu;\nconst Anchor = MenuAnchor;\nconst Portal = MenuPortal;\nconst Content = MenuContent;\nconst Group = MenuGroup;\nconst Label = MenuLabel;\nconst Item = MenuItem;\nconst CheckboxItem = MenuCheckboxItem;\nconst RadioGroup = MenuRadioGroup;\nconst RadioItem = MenuRadioItem;\nconst ItemIndicator = MenuItemIndicator;\nconst Separator = MenuSeparator;\nconst Arrow = MenuArrow;\nconst Sub = MenuSub;\nconst SubTrigger = MenuSubTrigger;\nconst SubContent = MenuSubContent;\n\nexport {\n  createMenuScope,\n  //\n  Menu,\n  MenuAnchor,\n  MenuPortal,\n  MenuContent,\n  MenuGroup,\n  MenuLabel,\n  MenuItem,\n  MenuCheckboxItem,\n  MenuRadioGroup,\n  MenuRadioItem,\n  MenuItemIndicator,\n  MenuSeparator,\n  MenuArrow,\n  MenuSub,\n  MenuSubTrigger,\n  MenuSubContent,\n  //\n  Root,\n  Anchor,\n  Portal,\n  Content,\n  Group,\n  Label,\n  Item,\n  CheckboxItem,\n  RadioGroup,\n  RadioItem,\n  ItemIndicator,\n  Separator,\n  Arrow,\n  Sub,\n  SubTrigger,\n  SubContent,\n};\nexport type {\n  MenuProps,\n  MenuAnchorProps,\n  MenuPortalProps,\n  MenuContentProps,\n  MenuGroupProps,\n  MenuLabelProps,\n  MenuItemProps,\n  MenuCheckboxItemProps,\n  MenuRadioGroupProps,\n  MenuRadioItemProps,\n  MenuItemIndicatorProps,\n  MenuSeparatorProps,\n  MenuArrowProps,\n  MenuSubProps,\n  MenuSubTriggerProps,\n  MenuSubContentProps,\n};\n",null],"names":["SELECTION_KEYS","FIRST_KEYS","LAST_KEYS","FIRST_LAST_KEYS","SUB_OPEN_KEYS","ltr","rtl","SUB_CLOSE_KEYS","MENU_NAME","Collection","useCollection","createCollectionScope","createCollection","createMenuContext","createMenuScope","createContextScope","usePopperScope","createPopperScope","useRovingFocusGroupScope","createRovingFocusGroupScope","MenuProvider","useMenuContext","MenuRootProvider","useMenuRootContext","Menu","props","__scopeMenu","open","children","dir","onOpenChange","modal","popperScope","content","setContent","React","isUsingKeyboardRef","handleOpenChange","useCallbackRef","direction","useDirection","handleKeyDown","current","document","addEventListener","handlePointer","capture","once","removeEventListener","ANCHOR_NAME","MenuAnchor","forwardedRef","anchorProps","PORTAL_NAME","PortalProvider","usePortalContext","forceMount","undefined","MenuPortal","container","context","CONTENT_NAME","MenuContentProvider","useMenuContentContext","MenuContent","portalContext","contentProps","rootContext","MenuRootContentModal","ref","composedRefs","useComposedRefs","hideOthers","composeEventHandlers","onFocusOutside","event","preventDefault","checkForDefaultPrevented","MenuRootContentNonModal","MenuContentImpl","loop","trapFocus","onOpenAutoFocus","onCloseAutoFocus","disableOutsidePointerEvents","onEntryFocus","onEscapeKeyDown","onPointerDownOutside","onInteractOutside","onDismiss","disableOutsideScroll","rovingFocusGroupScope","getItems","currentItemId","setCurrentItemId","contentRef","onContentChange","timerRef","searchRef","pointerGraceTimerRef","pointerGraceIntentRef","pointerDirRef","lastPointerXRef","ScrollLockWrapper","scrollLockWrapperProps","as","allowPinchZoom","handleTypeaheadSearch","key","search","items","filter","item","disabled","currentItem","activeElement","currentMatch","find","textValue","values","map","nextMatch","getNextMatch","newItem","updateSearch","value","window","clearTimeout","setTimeout","focus","useFocusGuards","isPointerMovingToSubmenu","isMovingTowards","side","isPointerInGraceArea","area","intent","getOpenState","outline","style","onKeyDown","target","isKeyDownInside","closest","currentTarget","isModifierKey","ctrlKey","altKey","metaKey","isCharacterKey","length","includes","candidateNodes","reverse","focusFirst","onBlur","contains","onPointerMove","whenMouse","pointerXHasChanged","clientX","newDir","GROUP_NAME","MenuGroup","groupProps","LABEL_NAME","MenuLabel","labelProps","ITEM_NAME","ITEM_SELECT","MenuItem","onSelect","itemProps","contentContext","isPointerDownRef","handleSelect","menuItem","itemSelectEvent","CustomEvent","bubbles","cancelable","dispatchDiscreteCustomEvent","defaultPrevented","onClose","onClick","onPointerDown","onPointerUp","click","isTypingAhead","MenuItemImpl","isFocused","setIsFocused","textContent","setTextContent","trim","onItemLeave","onItemEnter","onPointerLeave","onFocus","CHECKBOX_ITEM_NAME","MenuCheckboxItem","checked","onCheckedChange","checkboxItemProps","isIndeterminate","getCheckedState","RADIO_GROUP_NAME","RadioGroupProvider","useRadioGroupContext","onValueChange","MenuRadioGroup","handleValueChange","RADIO_ITEM_NAME","MenuRadioItem","radioItemProps","ITEM_INDICATOR_NAME","ItemIndicatorProvider","useItemIndicatorContext","MenuItemIndicator","itemIndicatorProps","indicatorContext","SEPARATOR_NAME","MenuSeparator","separatorProps","ARROW_NAME","MenuArrow","arrowProps","SUB_NAME","MenuSubProvider","useMenuSubContext","MenuSub","parentMenuContext","trigger","setTrigger","useId","SUB_TRIGGER_NAME","MenuSubTrigger","subContext","openTimerRef","onPointerGraceIntentChange","scope","clearOpenTimer","pointerGraceTimer","triggerId","contentId","composeRefs","onTriggerChange","contentRect","getBoundingClientRect","dataset","rightSide","bleed","contentNearEdge","contentFarEdge","x","y","clientY","top","bottom","onTriggerLeave","SUB_CONTENT_NAME","MenuSubContent","subContentProps","isCloseKey","candidates","PREVIOUSLY_FOCUSED_ELEMENT","candidate","wrapArray","array","startIndex","_","index","isRepeated","Array","from","every","char","normalizedSearch","currentMatchIndex","indexOf","wrappedValues","Math","max","excludeCurrentMatch","v","toLowerCase","startsWith","isPointInPolygon","point","polygon","inside","i","j","xi","yi","xj","yj","intersect","cursorPos","handler","pointerType","Root","Anchor","Portal","Content","Group","Label","Item","CheckboxItem","RadioGroup","RadioItem","ItemIndicator","Separator","Arrow","Sub","SubTrigger","SubContent"],"mappings":"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"}},
    {"offset": {"line": 999, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}